import 'dart:convert';
import 'package:encrypt/encrypt.dart';

/// A service class to handle string encryption and decryption using AES-256 GCM.
///
/// NOTE: AES GCM is chosen for its authenticated encryption capabilities,
/// ensuring both privacy and integrity of the data.
class EncryptionService {
  final Encrypter _encrypter;
  final Key _key;

  /// Initializes the EncryptionService with a 256-bit Key.
  /// The key should be securely generated and stored (e.g., using Flutter Secure Storage).
  EncryptionService(String base64Key)
    : _key = Key.fromBase64(base64Key),
      _encrypter = Encrypter(
        // Use AES-256 with GCM mode
        // GCM mode requires a non-null IV (Initialization Vector)
        AES(Key.fromBase64(base64Key), mode: AESMode.gcm),
      );

  /// Encrypts a plaintext string.
  /// Returns a JSON string containing the base64-encoded IV and the encrypted text.
  String encrypt(String plaintext) {
    // Generate a secure 96-bit (12-byte) IV for GCM mode
    final iv = IV.fromSecureRandom(12);

    // Encrypt the data
    final encrypted = _encrypter.encrypt(plaintext, iv: iv);

    // Combine IV and encrypted data into a JSON structure for storage/transmission
    // This allows the receiver to have both pieces needed for decryption
    final encryptedData = {'iv': iv.base64, 'encryptedText': encrypted.base64};

    return jsonEncode(encryptedData);
  }

  /// Decrypts an encrypted string.
  /// The input must be a JSON string generated by the `encrypt` method.
  String? decrypt(String encryptedJson) {
    try {
      final Map<String, dynamic> encryptedData = jsonDecode(encryptedJson);

      final iv = IV.fromBase64(encryptedData['iv']);
      final encrypted = Encrypted.fromBase64(encryptedData['encryptedText']);

      // Decrypt the data
      return _encrypter.decrypt(encrypted, iv: iv);
    } catch (e) {
      // Log error if decryption fails (e.g., wrong key, corrupted IV, or invalid JSON)
      print('Decryption Error: $e');
      return null;
    }
  }
}

// --- Example Usage ---

// A helper function to generate a secure random 256-bit key (32 bytes)
String generateSecureKey() {
  return Key.fromSecureRandom(32).base64;
}

void main() {
  // 1. Generate or retrieve the secure key (MUST be stored securely)
  final String secretKeyBase64 = generateSecureKey();
  print('--- Key Generated (Store this securely!) ---');
  print('Key (Base64): $secretKeyBase64\n');

  // 2. Initialize the service
  final cipher = EncryptionService(secretKeyBase64);

  // 3. Define the data
  const originalText = "This is the highly sensitive data for storage.";
  print('Original Text: $originalText\n');

  // 4. Encrypt
  final encryptedJson = cipher.encrypt(originalText);
  print('--- Encrypted Output (JSON string containing IV and cipher text) ---');
  print('Encrypted JSON: $encryptedJson\n');

  // 5. Decrypt
  final decryptedText = cipher.decrypt(encryptedJson);
  print('--- Decrypted Output ---');
  print('Decrypted Text: $decryptedText');

  // Verification
  if (decryptedText == originalText) {
    print('\n✅ Success: Decryption matches original text.');
  } else {
    print('\n❌ Failure: Decryption failed.');
  }

  // Example of a decryption failure (using a wrong key)
  print('\n--- Testing Decryption Failure (Wrong Key) ---');
  final String wrongKeyBase64 = generateSecureKey();
  final wrongCipher = EncryptionService(wrongKeyBase64);
  final failedDecryption = wrongCipher.decrypt(
    encryptedJson,
  ); // Using the cipher generated with the CORRECT key
  if (failedDecryption == null) {
    print('Decryption with wrong key resulted in NULL as expected.');
  }
}
